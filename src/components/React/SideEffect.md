# 컴포넌트를 순수하게 유지하기
> - 함수가 호출되기 전에 존재했던 어떤 객체나 변수는 변경하지 않는다.
> - 같은 입력이 주어졌다면 순수함수는 같은 결과를 반환한다.

### 📍 Side Effect
- **렌더링 외부에서 일어나는 변화**를 말한다.(ex. 화면 업데이트, API 호출,애니메이션 등)
- React의 렌더링 과정은 **항상 순수**해야 한다. -> **렌더링은 side effect를 포함하면 안 됨**
- 컴포넌트는 **JSX만 반환**해야 하며, **렌더링 이전에 존재했던 객체나 변수를 변경해서는 안된다.**
- 그래서 **보통 Side Effect는 이벤트 핸들러 안에 넣는다.**
- 그래도 이벤트로 처리할 수 없다면, `useEffect()` 를 사용해 렌더링 후에 실행되도록 한다.
  - 가능하다면 state와 props만으로 UI를 표현하는게 좋다.
  - `useEffect` 는 정말 필요할 때만 쓰는 최후의 수단이어야 한다.

### 🔎 왜? useEffect는 최후의 수단이어야 할까?
- `useEffect` 는 순수하지 않다.
  - 렌더링은 순수하게 state와 props만으로 UI를 표현하는 게 이상적
  - `useEffect` 를 사용하면 컴포넌트 외부의 상태나 동작을 건드릴 수 있어서 버그나 예측 어려운 동작의 원인이 되기 쉽다.
- 불필요한 실행으로 인한 성능 저하
  - useEffect는 의존성 배열에 따라 반복 실행된다.
  - 잘못 쓰면 불필요한 네트워크 요청, DOM 조작, 상태 변경 등이 반복적으로 발생할 수 있다.
- 로직이 useEffect에 퍼지기 시작하면 "언제 실행되나", "왜 실행되나" 파악하기 어려움
  - 로직이 분산되면서 디버깅이 어려워진다.

### 🔎 엄격 모드로 순수하지 않은 연산을 감지
- React에서 렌더링하면서 읽을 수 있는 3가지 종류의 입력 요소가 있다.
- `Props` ,`State` ,`Context` 는 항상 읽기 전용으로 취급해야 한다.
- 사용자의 입력에 따라 무언가를 변경하려는 경우, 변수를 직접 수정하는 대신 `State`를 설정해야 한다.
  - 컴포넌트가 렌더링되는 동안엔 기존 변수나 객체를 변경하면 안된다.

### 🔎 왜? 렌더링 중에 사이드 이펙트가 일어나면 안되는가?
- React 렌더링은 순수 함수처럼 동작해야 한다.
- 왜냐면 동일한 입력이 들어오면 항상 동일한 출력이 나와야 하기 때문이다.
- 이게 가능해야 React는
  - 자동으로 렌더링 순서를 최적화하고
  - 불필요한 렌더링을 건너뛰고
  - SSR, hydration, strict mode에서도 일관된 동작을 보장할 수 있다.
- 만약 렌더링 중에 사이드 이펙트가 있으면 **"예측 불가능"** 해진다.
```jsx
function MyComponent() {
  fetch('/data') // ❌ 잘못된 사이드 이펙트
  return <div>Hello</div>;
}
```

- 내부적으로 컴포넌트를 여러 번 렌더링 할 수 있다.
  - `StrictMode` 에서는 의도적으로 두 번 호출되기도 한다. (개발 중 사이드 이펙트 감지용)
- 렌더링이 여러번 되면 ➡️ `fetch` 도 여러 번 호출된다.
- 그러면 중복 요청, 상태 꼬임, 성능 이슈 발생이 가능해진다.
- 그래서 side Effect는 반드시 렌더링 이후에만 실행되어야 한다.

- React는 렌더링을 미루거나 되돌릴 수 있다. ➡️ 때에 따라 컴포넌트를 렌더링 해보고 실제 DOM에는 적용하지 않을 수도 있다.
  - `<Susoense>`로 로딩 중단
  - `<Transition>` 으로 애니메이션 중 상태 변경
- 이때, side Effect가 렌더링 중에 발생하면
  - 사용자가 보지도 않은 DOM에 이미 상태 변경이나 요청이 발생하여 큰 혼란을 야기할 수 있다.