## Three.js
> WebGL을 쉽게 다루게 해주는 3D 그래픽 엔진 역할을 하는 자바스크립트 라이브러리

- WebGL같은 저수준 그래픽 API를 추상화해서 쉽게 다룰 수 있게 해줌
- 직접 제어하지 않아도 3D 씬을 쉽게 만들 수 있게 해주는 도구
- 카메라, 씬, 렌더러, 조명, 메시-재질, 모델 로더 관리

```js
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight);
const renderer = new THREE.WebGLRenderer();

// 씬, 카메라, 렌더러 필수 설정

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshStandardMaterial({color: 0x00ff00})
)
scene.add(cube);

function animate(){
  requestAnimationFrame(animate);
  cube.rotation.x += 0.01;
  renderer.render(scene, camera);
}
animate();

```

## R3F - Three.js의 리액트화
: Three.js를 리액트 문법으로 선언적으로 다룰 수 있게 만든 라이브러리

- useFrame, useLoader, Canvas 등 훅 기반으로 동작
- 리액트 상태와 자연스럽게 연결 가능

```tsx
function Box() {
  const meshRef = useRef<any>();
  useFrame(() => {
    meshRef.current.rotation.x += 0.01;
  });

  return (
    <mesh ref={meshRef}>
      <boxGeometry />
      <meshStandardMaterial color="orange" />
    </mesh>
  )
}


export default function Scene() {
  return (
    <Canvas>
      <ambientLight />
      <pointLight position={[19,19,19]} />
      <Box />
    </Canvas>
  )
}
```

- JSX로 관리 가능 
- React 생명주기와 훅을 활용 가능
- 기존 Three.js의 씬, 카메라, 렌더러가 캔버스 컴포넌트 내부에서 자동 관리된다.

<br/>

## drei - R3F에서 자주 쓰는 기능을 모아둔 유틸모음집
| 종류            | 컴포넌트 / 훅                                                  | 설명                             |
| ------------- | --------------------------------------------------------- | ------------------------------ |
| **모델 로딩**     | `useGLTF()`                                               | GLTF 모델을 불러오고, 내부적으로 캐싱까지 처리   |
| **카메라 제어**    | `<OrbitControls />`                                       | 마우스로 드래그/줌/회전 가능하게 하는 카메라 컨트롤러 |
| **환경맵**       | `<Environment />`                                         | HDRI 환경 추가 (빛 반사/배경용)          |
| **HTML 오버레이** | `<Html />`                                                | 3D 공간 위에 실제 HTML 요소 배치         |
| **텍스트**       | `<Text />`                                                | 3D 공간 안에서 글자 렌더링               |
| **조명/반사**     | `<ContactShadows />`, `<SoftShadows />`                   | 그림자, 빛의 부드러운 표현                |
| **효과**        | `<CameraShake />`, `<Float />`, `<MeshDistortMaterial />` | 흔들림, 둥둥 뜨기, 물결 효과              |
| **유틸 훅**      | `useHelper`, `useAspect`, `useTexture`, `useCursor` 등     | 디버깅, 화면 비율, 텍스처 로드 등 편의 기능     |


<br/>

## 🔍 Q&A

### Q1. R3F가 뭔가요?
- R3F는 Three.js를 리액트 방식으로 사용할 수 있게 해주는 렌더러입니다.
- 기존적으로 Three.js는 씬과 객체를 직접 생성하고 관리해야 하지만,
- R3F는 이를 리액트의 선언형 컴포넌트 구조로 바꿔줍니다.
- 덕분에 3D 씬도 리액트 컴포넌트처럼 작성할 수 있고
- 리액트의 상태 관리나 훅 시스템도 그대로 활용할 수 있습니다.
- 즉, Three.js의 그래픽 엔진 위에서 리액트 생태계로 3D를 표현할 수 있게 해주는 브리지 역할을 합니다.

  ### 👀 R3F가 내부적으로 하는 일
  - `Canvas` 라는 영역 안에서
  - Three.js의 씬, 카메라, 렌더러를 자동으로 만들어준다.
  - 리액트 트리를 읽어서 ➡️ Three.js 오브젝트로 변환
  - 리액트 상태가 바뀌면 ➡️ 3D 씬에 바로 반영
  - `useFrame()` 훅을 통해 ➡️ 매 프레임마다 3D 씬을 업데이트

  ```js
  /// R3F 내부에 이렇게 생긴 루프가 존재
  function internalLoop() {
  requestAnimationFrame(internalLoop); // 매 프레임 반복
  runAllUseFrameCallbacks();            // useFrame 훅에 등록된 함수 실행
  renderer.render(scene, camera);       // 3D 씬 렌더링
  }
  ```
  ➡️ 즉, `useFrame()` 은 **프레임이 그려질 때 실행될 콜백 함수 등록기** 역할

### Q1-2. Three.js와 어떤 차이점이 있나요?
- Three.js는 그래픽 엔진, R3F는 그 엔진을 리액트 안에서 쉽게 쓸 수 있도록 해주는 역할
- Three.js는 매 프레임마다 직접 씬, 카메라, 렌더러를 업데이트 해야 하지만,
- R3F는 리액트가 렌더링 사이클을 관리해주기 때문에 컴포넌트 단위로 선언만 하면 자동으로 반영됩니다.

   ### 📍 리액트가 렌더링 사이클을 관리한다는 것
   - 렌더링 사이클 : 컴포넌트의 **상태가 변경될 때**, 리액트가 감지하고 언제 DOM을 다시 그리고, 어느 부분만 업데이트할지를 결정하는 흐름

    ### 📍 리액트의 렌더링 사이클 흐름
    1. 상태가 변경됨
    2. 리액트가 가상 DOM을 새로 계산
    3. 이전 가상 DOM과 비교 (Diffing)
    4. 변경된 부분만 실제 DOM에 반영
    5. 브라우저 화면 갱신

    ### 📍 가상 돔이란 뭔가요? 왜 필요하죠?
    > 브라우저 화면을 직접 조작하지 않고, 리액트가 메모리 속에서 가짜 돔 트리를 만들어 관리하는 개념

    - 원래 DOM 렌더링의 문제점
      - 브라우저의 실제 DOM 조작은 매우 느림
      - 요소가 많을수록 Repaint/Reflow 비용이 큼

    - 리액트는 렌더링 성능을 높이기 위해 실제 DOM을 바로 건드리지 않고, 가상 트리를 메모리에 유지

### Q1-3. 왜 R3F를 선택했나요?
- 3D 모델을 리액트 기반 서비스 구조 안에서 다뤄야 했기 때문에
- Three.js만으로는 상태 동기화나 UI 결합이 어렵다고 판단했습니다.
- 덕분에 잘 연결되어 리렌더링이나 사용자 상호작용이 훨씬 직관적이었습니다.

### Q1-4. 주의해야 할 점이 있을까요?
- 리액트와 Three.js는 렌더링 타이밍이 다르기 때문에, 불필요한 리렌더링이나 메모리 누수를 방지하는 최적화가 중요합니다.
- 예를 들어 useMemo, useCallback으로 객체 재생성을 방지하고
- useFrame 내부에서 델타를 이용해 애니메이션 속도를 일정하게 유지하며
- GLTF 모델은 preload()로 사전 로딩해 캐싱하는 등
- 이렇게 관리해주면 안정성과 UX 모두 좋아집니다.

### 📍 렌더링 타이밍이 어떻게 다른가요?
| 구분          | React                       | Three.js                         |
| ----------- | --------------------------- | -------------------------------- |
| **렌더링 트리거** | 상태(State)나 Props 변경 시       | 매 프레임마다(`requestAnimationFrame`) |
| **렌더링 주기**  | 필요할 때만 다시 그림 (비동기적)         | 1초에 60번 반복 (동기적 루프)              |
| **관심 대상**   | DOM / UI 트리                 | 3D 씬 / 카메라 / 오브젝트                |
| **업데이트 방식** | Virtual DOM 비교 후 변경된 부분만 갱신 | 전체 씬을 매 프레임 다시 렌더링               |

- 그래서 R3F가 이 2개의 타이밍을 동기화해주는 역할을 한다.

### Q1-5. WebGL이란?
- Web Graphics Library
- 웹 브라우저 안에서 GPU를 이용해 2D/3D 그래픽을 그릴 수 있게 해주는 저수준 그래픽 API
- GPU는 수천 개의 코어로 병렬 연산을 할 수 있어서, 빛의 반사나 그림자 같은 표현을 빠르게 계산할 수 있다.
- 하지만 자바스크립트로는 직접 제어할 수 없어서 나온게 WebGL

### Q2. drei는 뭔가요?
- R3F에서 자주 쓰는 기능들을 모아둔 유틸리티 라이브러리 입니다.
- 모델로더, 카메라 컨트롤, 그림자 효과 같은 걸 직접 구현하지 않아도 한 줄로 쉽게 쓸 수 있게 도와줍니다.

### Q2-2. 왜 drei를 사용했나요?
- 3D 모델을 불러오고 카메라 제어를 하능 기능이 많았는데, 이걸 Three.js로 직접 구현하면 코드가 길고 복잡해졌습니다.
- drei의 useGLTF나 OribitControls를 사용하면 코드의 복잡도를 줄이고 유지보수성을 높일 수 있어서 사용하게 되었습니다.

### Q2-3. drei는 R3F 내부에 포함되어 있나요?
- 아니요 별도의 패키지 입니다.
- R3F는 렌더러만 제공하고, drei는 자주 쓰는 구성요소를 모듈 형태로 제공하는 별도 확장 라이브러리 입니다.