## ê°€êµ¬ ëª¨ë¸ ë Œë”ë§ ë¡œì§
```jsx
import { useGLTF } from '@react-three/drei';
import { useEffect, useRef } from 'react';
import * as THREE from 'three';

export default function Furnitures({item, onInteract, onHover }:FurnitureProps) {
  const groupRef = useRef<THREE.Group>(null);
  // useRefëŠ” ë¦¬ì•¡íŠ¸ê°€ ë¦¬ë Œë”ë§ ë  ëŒ€ë„ ê°™ì€ ê°’ì„ ìœ ì§€í•˜ê²Œ í•´ì£¼ëŠ” "ì°¸ì¡° ì €ì¥ì†Œ"
  // 1. ë¦¬ì•¡íŠ¸ëŠ” ìƒíƒœê°€ ë°”ë€Œë©´ ë¦¬ë Œë”ê°€ ë¨ -> ì´ë•Œ ì¼ë°˜ ë³€ìˆ˜ëŠ” ì´ˆê¸°í™” ëœë‹¤.
  // 2. í•˜ì§€ë§Œ useRefëŠ” ë¦¬ì•¡íŠ¸ê°€ ë‹¤ì‹œ ë Œë”ë˜ë”ë¼ë„ ê¸°ì–µìƒì ì•ˆì˜ ë“  ê°’ì„ ìœ ì§€

  const { scene } = useGLTF(item.modelPath) as GLTFResult;
  // useGLTFëŠ” GLTF í˜•ì‹ì˜ 3D ëª¨ë¸ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ê³ , sceneì„ ë°˜í™˜,

  // useEffectëŠ” ë¦¬ì•¡íŠ¸ ì»´í¬ë„ŒíŠ¸ê°€ ë Œë”ë§ëœ ë’¤ì— ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
  // ì¦‰, ëª¨ë¸ì´ ë¡œë“œëœ ì´í›„ì— ê·¸ë¦¼ì ì„¤ì •ì„ ì ìš©í•˜ê¸° ìœ„í•´ ì‚¬ìš©
  useEffect(() => {
    if (scene) {
      // scene.traverse() : ì”¬ ì•ˆì˜ ëª¨ë“  ì˜¤ë¸Œì íŠ¸ë¥¼ í•˜ë‚˜ì”© ìˆœíšŒí•˜ëŠ” ë©”ì„œë“œ
      scene.traverse((object) => {
        // object.isMesh -> ì´ ì˜¤ë¸Œì íŠ¸ê°€ 3D ë©”ì‹œë¥¼ ê°€ì§„ ë Œë” ê°€ëŠ¥í•œ ê°ì²´ì¸ì§€ í™•ì¸
        if (object.isMesh) {
          // ê·¸ë¦¼ì ì„¤ì • : ì¡°ëª…ê³¼ ì…ì²´ê°ì„ í‘œí˜„í•˜ê¸° ìœ„í•´ ì‚¬ìš©
          object.castShadow = true;    // ê·¸ë¦¼ì ìƒì„±
          object.receiveShadow = true; // ê·¸ë¦¼ì ë°›ìŒ
        }
      });
    }
  }, [scene]);

  // ë§ˆìš°ìŠ¤ê°€ ì˜¤ë¸Œì íŠ¸ ìœ„ì— ì˜¬ë¼ì™”ì„ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
  const handlePointerOver = (e: MouseEvent) => {
    e.stopPropagation(); 
    // ì´ë²¤íŠ¸ ë²„ë¸”ë§ ë°©ì§€ -> ë‹¤ë¥¸ ìƒìœ„ ê°ì²´ë¡œ ì´ë²¤íŠ¸ ì „ë‹¬ ë§‰ê¸°
    // ì™œ ë²„ë¸”ë§ì„ ë§‰ì•˜ëƒ? -> ìƒìœ„ ê°ì²´ë‚˜ ì¹´ë©”ë¼ ì»¨íŠ¸ë¡¤ì—ë„ ì „ë‹¬ë¼ì„œ ì›ì¹˜ ì•Šì€ ë™ì‘ì´ ìƒê¸¸ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë§‰ìŒ
    // ë¶€ëª¨ ì»´í¬ë„ŒíŠ¸ì— hover ìƒíƒœë¥¼ ì•Œë ¤ì¤Œ
    if (onHover) onHover(item.type, true);

    // ëª¨ë¸ ì „ì²´ë¥¼ ìˆœíšŒí•˜ë©° ì¬ì§ˆì˜ ë°œê´‘ íš¨ê³¼ ì ìš©
    scene.traverse((object) => {
      if (object.isMesh) {
        object.material.emissive = object.material.color;
        object.material.emissiveIntensity = 0.5;
      }
    });
  };

  // ë§ˆìš°ìŠ¤ê°€ ì˜¤ë¸Œì íŠ¸ ë°–ìœ¼ë¡œ ë‚˜ê°”ì„ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
  const handlePointerOut = (e: MouseEvent) => {
    e.stopPropagation();
    if (onHover) onHover(item.type, false);
    
    scene.traverse((object) => {
      if (object.isMesh) {
        object.material.emissiveIntensity = 0;
      }
    });
  };

  return (
    <group
      ref={groupRef}
      position={new THREE.Vector3(...item.position)} 
      // [x,y,z] ì¢Œí‘œë¥¼ Vector3ë¡œ ë³€í™˜í•´ ìœ„ì¹˜ ì§€ì •
      //  Vector3 : 3D ê³µê°„ì—ì„œì˜ ì¢Œí‘œë‚˜ ë°©í–¥ì„ í‘œí˜„í•˜ëŠ” ìˆ˜í•™ì  ë²¡í„° ê°ì²´
      scale={item.scale || 0.68}
      rotation={new THREE.Euler(...item.rotation)}
      onClick={(e) => {
        e.stopPropagation();
        if (onInteract) onInteract(item.type);
      }}
      onPointerOver={handlePointerOver}
      onPointerOut={handlePointerOut}
    >
      <primitive object={scene} />
      // primitiveëŠ” R3Fê°€ Three.js ì›ë³¸ ê°ì²´ë¥¼ ê·¸ëŒ€ë¡œ ì‚½ì…í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ì»´í¬ë„ŒíŠ¸
      // ëª¨ë¸ì„ ë¶ˆëŸ¬ì™”ê¸° ë•Œë¬¸ì— ì´ê±¸ ì“°ëŠ” ê²ƒ

    </group>
  );
}

```

<br/>

## 3D ë£¸ ë‹¨ì¼ ë Œë” ì»´í¬ë„ŒíŠ¸
- í˜„ì¬ ìƒíƒœì—ì„œëŠ” í´ë¡ ì€ í•„ìš” ì—†ì§€ë§Œ
- ì¶”í›„ ë²½ì§€ ìƒ‰ìƒì´ë‚˜ ë°”ë‹¥ìƒ‰ìƒì„ ë°”ê¾¼ë‹¤ë©´, í´ë¡ ì´ í•„ìš”
- í•˜ì§€ë§Œ í´ë¡ ì€ GPU ë©”ëª¨ë¦¬ ë‚­ë¹„ê°€ ìˆìŒ

```jsx
import { Center, useGLTF } from '@react-three/drei';
import { useEffect, useMemo } from 'react';
import * as THREE from 'three';

export default function HiveRoomModel({ room, position, onModelLoaded }: HiveRoomModelProps) {

  const { scene: originalScene } = useGLTF(room.modelPath) as GLTFResult;

  // ë Œë”ë§ ì¤‘ì—ë„ 'scene'ì„ ë§¤ë²ˆ ìƒˆë¡œ ë³µì œí•˜ì§€ ì•Šë„ë¡ ìºì‹±
  // originalSceneì´ ë°”ë€” ë•Œë§Œ ì¬ìƒì„±
  const scene = useMemo(() => {
    // clone() : originalSceneì„ ë³µì‚¬ / ì´ë ‡ê²Œ í•´ì•¼ ëª¨ë¸ ê°„ ë¨¸í‹°ë¦¬ì–¼/ì§€ì˜¤ë©”íŠ¸ë¦¬ ì°¸ì¡°ê°€ ê²¹ì¹˜ì§€ ì•ŠìŒ
    const clonedScene = originalScene.clone();

    clonedScene.traverse((object: THREE.Object3D) => {
      if (object instanceof THREE.Mesh) {
        object.material = (object.material as THREE.Material).clone();
        object.geometry = object.geometry.clone();

        object.castShadow = true;
        object.receiveShadow = true;
      }
    });
    return clonedScene;
  }, [originalScene]);

  const roomScale = 0.5;

  // ì”¬ì´ ë¡œë“œë˜ê³  ë‚˜ë©´ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • ë° í¬ê¸° ê³„ì‚°
  useEffect(() => {
    if (!scene) return;

    // ë¶€ëª¨ì—ì„œ ì „ë‹¬ë°›ì€ í¬ì§€ì…˜ ê°’ìœ¼ë¡œ ì„¤ì •
    scene.position.set(...position);

    // 3D ëª¨ë¸ì˜ ê²½ê³„ ìƒìë¥¼ ê³„ì‚°í•˜ëŠ” í´ë˜ìŠ¤
    // setFromObject(scene) -> ëª¨ë¸ ì „ì²´ì˜ ë°”ìš´ë”© ë°•ìŠ¤ë¥¼ ìƒì„±
    const box = new THREE.Box3().setFromObject(scene);

    // ë°© ëª¨ë¸ì˜ ì„¼í„° êµ¬í•¨
    const center = new THREE.Vector3();

    // ëª¨ë¸ì˜ ì¤‘ì‹¬ ì¢Œí‘œì— ê²½ê³„ë°•ìŠ¤ ì„¤ì •
    box.getCenter(center);

    // ëª¨ë¸ ë¡œë“œ ë˜ì—ˆëŠ”ì§€ í™•ì¸
    onModelLoaded(room.roomId);
  }, [scene, room.roomId, position, onModelLoaded]);

  return (
    // ë‚´ë¶€ ê°ì²´ë¥¼ ìë™ìœ¼ë¡œ ì¤‘ì‹¬ ì •ë ¬ ì‹œì¼œì¤Œ
      <Center>
        <primitive
          object={scene}
          scale={roomScale}
          rotation={[0, -Math.PI / 4, 0]}
        />
      </Center>
  );
}

```

<br/>

## ë©”ì¸ ì „ì²´ ë°©
```tsx
import { OrbitControls } from '@react-three/drei';
import { Canvas } from '@react-three/fiber';
import { useCallback, useEffect, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import * as THREE from 'three';
import Loading from '../../../components/Loading';
import { RoomLighting } from '../../../components/room-models/RoomLighting';
import useHexagonGrid from '../hooks/useHexagonGrid';
import useRooms from '../hooks/useRooms';
import HiveRoomModel from './HiveRoomModel';

export default function HiveRooms({
  myUserId,
  onLoadingComplete,
}: HiveRoomsProps) {
  const { rooms } = useRooms(30, myUserId);
  const positionedRooms = useHexagonGrid(rooms, 0, 0);
  const [isLoading, setIsLoading] = useState(true);
  const [loadedRooms, setLoadedRooms] = useState(new Set());
  const [hoveredRoom, setHoveredRoom] = useState<number | null>(null);
  const navigate = useNavigate();
  // í˜„ì¬ ë¯¸ì‚¬ìš© ë¡œì§
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  // í´ë¦­/ë“œë˜ê·¸ êµ¬ë¶„
  const startPos = useRef<{ x: number; y: number } | null>(null);
  const tapThreshold = 8;

  // í¬ì¸í„° ëˆ„ë¥¼ ë•Œ í˜„ì¬ ì¢Œí‘œ ì €ì¥
  const handlePointerDown = (e: React.PointerEvent) => {
    startPos.current = { x: e.clientX, y: e.clientY };
  };

  const handlePointerUp = (e: React.PointerEvent, roomIndex: number) => {
    if (!startPos.current) return;
    // ClientX/Y : í™”ë©´ ê¸°ì¤€ì—ì„œ ë§ˆìš°ìŠ¤ í¬ì¸íŠ¸ì˜ í˜„ì¬ ìœ„ì¹˜(ì™„ìª½ ìƒë‹¨ì„ ê¸°ì¤€)
    const dx = e.clientX - startPos.current.x;
    const dy = e.clientY - startPos.current.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // ê±°ë¦¬ê°€ ì‘ìœ¼ë©´ íƒ­ìœ¼ë¡œ í´ë¦­ ì²˜ë¦¬ -> ë°© ì´ë™ í˜¸ì¶œ
    if (distance < tapThreshold) {
      const room = rooms[roomIndex];
      if (room?.userId) {
        navigate(`/room/${room.userId}`);
      }
    }
    startPos.current = null;
  };

  const handlePointerOver = useCallback((index: number) => {
    setHoveredRoom(index);
  }, []);

  const handlePointerOut = useCallback(() => {
    setHoveredRoom(null);
  }, []);

  const handleModelLoaded = useCallback((roomId: string) => {
    setLoadedRooms((prev) => {
      if (prev.has(roomId)) return prev;
      const newSet = new Set(prev);
      newSet.add(roomId);
      return newSet;
    });
  }, []);

  useEffect(() => {
    if (loadedRooms.size === rooms.length && rooms.length > 0) {
      setIsLoading(false);
      if (onLoadingComplete) onLoadingComplete();
    }
  }, [loadedRooms, rooms.length, onLoadingComplete]);

  return (
    <div className='w-full h-screen relative'>
      {isLoading && <Loading />}
      <Canvas
        ref={canvasRef}
        camera={{ position: [0, 4, 10], fov: 25 }}
        shadows>
        <RoomLighting />
        <directionalLight
          position={[10, 10, 10]}
          intensity={1.5}
          castShadow
          shadow-mapSize-width={1024}
          shadow-mapSize-height={1024}
        />
        {positionedRooms.map(({ room, position }, index: number) => (
          <group
            key={index}
            position={position}
            onPointerDown={handlePointerDown}
            onPointerUp={(e) => handlePointerUp(e, index)}
            onPointerOver={() => handlePointerOver(index)}
            onPointerOut={handlePointerOut}>
            
            <HiveRoomModel
              room={room}
              position={position}
              onModelLoaded={handleModelLoaded}
            />
          </group>
        ))}
        <OrbitControls
          enableRotate={false}
          enableZoom={true}
          enablePan={true}
          minDistance={5}
          maxDistance={14}
          mouseButtons={{ LEFT: THREE.MOUSE.PAN }}
          touches={{
            ONE: THREE.TOUCH.PAN,
            TWO: THREE.TOUCH.DOLLY_PAN,
          }}
        />
      </Canvas>
      {hoveredRoom !== null && (
        <div
          className='absolute bottom-22 left-1/2 transform -translate-x-1/2 font-medium z-30'
          style={{
            padding: '8px 20px',
            background: 'rgba(47, 71, 131, 0.4)',
            backdropFilter: 'blur(10px)',
            color: 'white',
            borderRadius: '40px',
            fontSize: '14px',
            pointerEvents: 'none',
            whiteSpace: 'nowrap',
            opacity: hoveredRoom !== null ? 1 : 0,
            transition: 'opacity 0.2s ease-in-out',
          }}>
          {`âœŠğŸ» ë˜‘ë˜‘! ${rooms[hoveredRoom]?.nickname}ì˜ ë°©ì— ë“¤ì–´ê°€ì‹¤ë˜ìš”?`}
        </div>
      )}
    </div>
  );
}

```

<br/>

## ë°© ì •ë³´ ë§¤í•‘
```jsx
import { useEffect, useState } from 'react';
import { housemateAPI } from '../../../apis/housemate';
import { roomAPI } from '../../../apis/room';
import { FullThemeData } from '../../../constants/roomTheme';

function mapThemeKeyToFullThemeKey(
  themeKey: string,
): keyof typeof FullThemeData {
  const themeMapping = {
    BASIC: 'FULL_BASIC',
    FOREST: 'FULL_FOREST',
    MARINE: 'FULL_MARINE',
  };

  return (themeMapping[themeKey as keyof typeof themeMapping] ||
    'FULL_BASIC') as keyof typeof FullThemeData;
}

export default function useRooms(limit = 30, myUserId: number) {
  const [rooms, setRooms] = useState<Room[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        let myRoom = null;
        if (typeof myUserId === 'number') {
          const myRoomData = await roomAPI.getRoomById(myUserId);
          const myThemeKey = mapThemeKeyToFullThemeKey(myRoomData.theme);
          const myTheme = FullThemeData[myThemeKey] || FullThemeData.FULL_BASIC;
          myRoom = { ...myRoomData, modelPath: myTheme.modelPath };
        } else {
          console.warn('myUserIdê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ:', myUserId);
        }

        const houseMateUsers = await housemateAPI.getFollowing(0, limit);

        const roomData = await Promise.all(
          houseMateUsers?.housemates?.map((mate: Housemate) =>
            roomAPI.getRoomById(mate.userId),
          ),
        );

        const modelRooms = roomData.map((room) => {
          const themeKey = mapThemeKeyToFullThemeKey(room.theme);
          const theme = FullThemeData[themeKey] || FullThemeData.FULL_BASIC;
          // // console.log('Room theme:', room.theme);
          return {
            ...room,
            modelPath: theme.modelPath,
          };
        });

        const allRooms = myRoom ? [myRoom, ...modelRooms] : modelRooms;
        setRooms(allRooms);
      } catch (error) {
        setError(error);
        console.error('ë°© ì •ë³´ íŒ¨ì¹˜ ì‹¤íŒ¨:', error);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [limit, myUserId]);

  return { rooms, loading, error };
}

```